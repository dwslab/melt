package de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api;

import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Default vocabulary as given by <a href="http://alignapi.gforge.inria.fr/labels.html">http://alignapi.gforge.inria.fr/labels.html</a>.
 *
 * @author Jan Portisch
 */
public class DefaultExtensions {

    /**
     * Standard API extensions by the AlignmentAPI.
     */
    public enum StandardApi {

        /**
         * STRING identifying the version of the alignment.
         */
        VERSION("version"),

        /**
         * CLASSNAME of the generating matching method (or operation).
         */
        METHOD("method"),

        /**
         * STRING identifying the method version.
         */
        METHOD_VERSION("methodVersion"),

        /**
         * URI the alignment from which this one is issued, if applicable
         */
        DERIVED_FROM("derivedFrom"),

        /**
         * STRING the parameters used with the generating method.
         */
        PARAMETERS("parameters"),

        /**
         * STRING a certificate from an issuing source.
         */
        CERTIFICATE("certificate"),

        /**
         * DURATION (default: INTEGER in milliseconds) of the matching process.
         */
        TIME("time"),

        /**
         * STRING the validity range of the correspondence.
         */
        LIMITATIONS("limitations"),

        /**
         * STRING the properties satisfied by an alignment or correspondences.
         */
        PROPERTIES("properties"),

        /**
         * STRING a short descriptive name of the alignment.
         */
        PRETTY("pretty"),

        /**
         * STRING a short descriptive name for the first aligned entity (in correspondences).
         */
        LABEL_1("label1"),

        /**
         * STRING a short descriptive name for the second aligned entity (in correspondences).
         */
        LABEL_2("label2"),

        /**
         * STRING identify the tools and versions who created the alignments (concatenated by ;).
         */
        PROVENANCE("provenance");

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://exmo.inrialpes.fr/align/ext/1.0/#";

        StandardApi(String attribute){
            this.uri = BASE_URI + attribute;
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


    /**
     * Linkkey Extensions
     */
    public enum Linkkey {

        /**
         * STRING describes the type of linkkey when extracted (weak/strong/plain).
         */
        TYPE,

        /**
         * PERCENTAGE of links in a sample, which are generated by the linkkey (relative recall).
         */
        RRECALL,

        /**
         * PERCENTAGE of links generated by the linkkey, which are in a sample (relative precision).
         */
        RPRECISION,

        /**
         * PERCENTAGE of one-to-one links generated by the linkkey on a particular dataset.
         */
        COVERAGE,

        /**
         * PERCENTAGE of instances which are linked by this linkkey on a particular dataset.
         */
        DISCRIMINABILITY;

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://melinda.inrialpes.fr/ns/linkkey/";

        Linkkey(){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


    /**
     * Dublin Core Extensions
     */
    public enum DublinCore {

        /**
         * STRING identifying an entity primarily responsible for making the alignment.
         */
        CREATOR,

        /**
         * TIMESTAMP of an event in the lifecycle of the alignment.
         */
        DATE,

        /**
         * STRING describing the alignment.
         */
        DESCRIPTION,

        /**
         * sameAs http://knowledgeweb.semanticweb.org/heterogeneity/alignment#id.
         */
        IDENTIFIER,

        /**
         * STRING providing information about rights held in and over the alignment.
         */
        RIGHTS,

        /**
         * sameAs http://exmo.inrialpes.fr/align/ext/1.0/#pretty.
         */
        TITLE;

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://purl.org/dc/elements/1.1/";

        DublinCore(){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


    /**
     * OMWG Extensions
     */
    public enum OMWG {

        /**
         * STRING The purpose for which an alignment has been defined
         */
        PURPOSE("http://www.owmg.org/TR/d7/d7.2/purpose");

        /**
         * The URI of the extension label.
         */
        private String uri;

        OMWG(String uri){
            this.uri = uri;
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }

    /**
     * Alignment server extensions.
     */
    public enum AlignmentServer {

        /**
         * STRING uniquely identifying the alignment.
         */
        ALID,

        /**
         * TIMESTAMP of the last time the alignment was read
         */
        CACHED,

        /**
         * TIMESTAMP of the time the alignment was stored in database.
         */
        STORED,

        /**
         * URI of the first ontology (temporary store).
         */
        OURI1,

        /**
         * URI of the second ontology (temporary store).
         */
        OURI2;

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://exmo.inrialpes.fr/align/service#";

        AlignmentServer(){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


    /**
     * Argumentation Extensions
     */
    public enum Argumentation {

        /**
         * STRING denoting an argument for the correspondence to be valid or invalid.
         */
        REASON,

        /**
         * STRING denoting the type of method used for supporting a correspondence (this is a value in value argumentation framework).
         */
        TYPE,

        /**
         * BOOLEAN denoting if the argument is in favour or against
         */
        SUPPORT;

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://ac.liv.ac.uk/just#";

        Argumentation(){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


    /**
     * Ontology Metadata Vocabulary being a metadata ontology introduces many different labels that can be used in
     * Alignment and correspondences but also defines it own sorts of objects that can be annotated.
     */
    public enum OmvMetadata {

        //-----------------------------------------------------------------------------------------
        // Basic Alignment Metadata
        //-----------------------------------------------------------------------------------------

        /**
         * Is the OMV type for all mapping objects, can be used as extensions for specifying a subclass of omv:Mapping.
         */
        MAPPING("Mapping"),

        /**
         *  sameAs http://exmo.inrialpes.fr/align/ext/1.0/#parameters
         */
        HAS_PARAMETER("hasParameter"),

        /**
         * sameAs http://purl.org/dc/elements/1.1/:creator
         */
        HAS_CREATOR("hasCreator"),

        /**
         * sameAs http://exmo.inrialpes.fr/align/ext/1.0/#method
         */
        USED_METHOD("usedMethod"),

        /**
         * STRING denoting [??]
         */
        VARIETY("variety"),

        /**
         * sameAs http://knowledgeweb.semanticweb.org/heterogeneity/alignment#type
         */
        TYPE("type"),

        /**
         * sameAs http://www.owmg.org/TR/d7/d7.2/purpose
         */
        PURPOSE("purpose"),

        /**
         * sameAs http://knowledgeweb.semanticweb.org/heterogeneity/alignment#id
         */
        URI("URI"),

        /**
         * sameAs http://exmo.inrialpes.fr/align/ext/1.0/#time
         */
        PROCESSING_TIME("processingTime"),

        /**
         * STRING denoting [??]
         */
        VALUE("value"),

        /**
         * sameAs http://purl.org/dc/elements/1.1/:language
         */
        NATURAL_LANGUAGE("naturalLanguage"),

        /**
         * sameAs http://knowledgeweb.semanticweb.org/heterogeneity/alignment#level
         */
        LEVEL("level"),

        /**
         * sameAs http://knowledgeweb.semanticweb.org/heterogeneity/alignment#uri1
         */
        SOURCE("source"),

        /**
         * sameAs http://purl.org/dc/elements/1.1/:date
         */
        CREATION_DATE("creationDate"),

        /**
         * sameAs http://exmo.inrialpes.fr/align/ext/1.0/#methodVersion
         */
        VERSION("version"),


        //-----------------------------------------------------------------------------------------
        // Matching Method Metadata
        //-----------------------------------------------------------------------------------------

        /**
         * is the OMV class of mapping methods
         */
        MAPPING_METHOD("MappingMethod"),

        /**
         * STRING denoting an atomic method
         */
        BASIC_METHOD("BasicMethod"),

        /**
         * sameAs http://exmo.inrialpes.fr/align/ext/1.0/#method="manual"
         */
        MANUAL_METHOD("ManualMethod"),

        /**
         * STRING denotting a method made by composing other methods
         */
        COMPOUND_METHOD("CompoundMethod"),

        /**
         * STRING denoting a method obtained by parallel composition of other methods
         */
        PARALLEL("Parallel"),

        /**
         * STRING denoting a method obtained by parallel composition of other methods
         */
        SEQUENCE("Sequence"),

        /**
         * STRING denoting the parameters of the method
         */
        PARAMETER("Parameter"),

        /**
         * #CompoundMethod linking a compound method to its components
         */
        COMPOSES_METHOD("composesMethod"),

        /**
         * #Method denoting the aggregation of the result of several methods
         */
        AGGREGATES_METHOD("aggregatesMethod"),

        /**
         * STRING denoting a method made by filtering the result of another
         */
        FILTER("Filter"),

        /**
         * #Method links a filter to the method it filters
         */
        FILTERS_METHOD("filtersMethod"),

        /**
         * STRING denoting the name of an algorithm implemented by a BasicMethod
         */
        ALGORITHM("Algorithm"),


        //-----------------------------------------------------------------------------------------
        // Evidence metadata
        //-----------------------------------------------------------------------------------------

        /**
         * #Property linking to properties satisfied by the alignment
         */
        HAS_PROPERTY("hasProperty"),

        /**
         * STRING denoting evidence in favour of the alignment properties
         */
        EVIDENCE("Evidence"),

        /**
         * STRING denoting proofs of properties
         */
        PROOF("Proof"),

        /**
         * STRING denoting properties that an alignment may satisfy
         */
        PROPERTY("Property"),

        /**
         * #Evidence linking to the evidence for a property
         */
        HAS_EVIDENCE("hasEvidence");

        /**
         * The URI of the extension label.
         */
        private String uri;
        
        public static final String BASE_URI = "http://omv.ontoware.org/2007/05/mappingomv#";

        OmvMetadata(String attribute){
            this.uri = BASE_URI + attribute;
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }
    
    /**
     * <a href="https://mapping-commons.github.io/sssom/">SSSOM Extensions</a>
     */
    public enum SSSOM {
        
        
        /****************************************************************************
         * Keys to be used on a Correspondence and Alignment Level
         ****************************************************************************/
        
        /**
         * LIST OF STRINGS: Identifies the persons or groups responsible for the creation of the mapping.
         * The creator is the agent that put the mapping in its published form, which may be different from the author,
         * which is a person that was actively involved in the assertion of the mapping.
         * Recommended to be a (pipe-separated) list of ORCIDs or otherwise identifying URLs,
         * but any identifying string (such as name and affiliation) is permissible.
         */
        CREATOR_ID(true, List.class),
        
        /**
         * STRING A string identifying the creator of this mapping. In the spirit of provenance, consider to use creator_id instead.
         */
        CREATOR_LABEL,
        
        /**
         * STRING A url to the license of the mapping. In absence of a license we assume no license.
         */
        LICENSE,
        
        /**
         * {@link SSSOMEntityType}: The type of entity that is being mapped.
         */
        SUBJECT_TYPE(SSSOMEntityType.class),
        
        /**
         * STRING URI of ontology source for the subject.
         */
        SUBJECT_SOURCE(true),
        
        /**
         * STRING Version IRI or version string of the source of the subject term.
         */
        SUBJECT_SOURCE_VERSION,
        
        /**
         * {@link SSSOMEntityType} The type of entity that is being mapped.
         */
        OBJECT_TYPE(SSSOMEntityType.class),
        
        /**
         * STRING IRI of ontology source for the object. Version IRI preferred.
         */
        OBJECT_SOURCE(true),
        
        /**
         * STRING Version IRI or version string of the source of the object term.
         */
        OBJECT_SOURCE_VERSION,
        
        /**
         * STRING URL pointing to the source that provided the mapping,
         * for example an ontology that already contains the mappings, or a database from which it was derived.
         */
        MAPPING_PROVIDER,
        
        /**
         * STRING A reference to the tool or algorithm that was used to generate the mapping.
         * Should be a URL pointing to more info about it, but can be free text.
         */
        MAPPING_TOOL,
        
        /**
         * STRING Version string that denotes the version of the mapping tool used.
         */
        MAPPING_TOOL_VERSION,
        
        /**
         * LocalDate: The date the mapping was asserted. This is different from the date the mapping was published or compiled in a SSSOM file.
         */
        MAPPING_DATE(LocalDate.class),
        
        /**
         * LIST OF STRING A tuple of fields (term annotations on the subject) that was used for the match.
         */
        SUBJECT_MATCH_FIELD(true, List.class),
        
        /**
         * LIST OF STRING A tuple of fields (term annotations on the object) that was used for the match.
         */
        OBJECT_MATCH_FIELD(true, List.class),
        
        /**
         * STRING Method of preprocessing applied to the fields of the subject.
         * If different preprocessing steps were performed on different fields, it is recommended to store the match in separate rows.
         */
        SUBJECT_PREPROCESSING(true),
        
        /**
         * STRING Method of preprocessing applied to the fields of the object.
         * If different preprocessing steps were performed on different fields, it is recommended to store the match in separate rows.
         */
        OBJECT_PREPROCESSING(true),
        
        /**
         * LIST OF STRING A URL specific for the mapping instance. E.g. for kboom we have a per-mapping image that shows surrounding
         * axioms that drive probability.Could also be a github issue URL that discussed a complicated alignment
         */
        SEE_ALSO(List.class),
        
        /**
         * STRING Pipe separated list of key value pairs for properties not part of the SSSOM spec. Can be used to encode additional provenance data.
         */
        OTHER,
        
        /**
         * STRING Free text field containing either curator notes or text generated by tool providing additional informative information.
         */
        COMMENT,
        
        
        /****************************************************************************
         * Keys to be used on a Alignment Level
         ****************************************************************************/
        
        
        /**
         * STRING: A globally unique identifier for the mapping set (not each individual mapping). Should be IRI, ideally resolvable.
         */
        MAPPING_SET_ID,

        /**
         * STRING: A version string for the mapping.
         */
        MAPPING_SET_VERSION,

        /**
         * LIST OF STRINGS: A mapping set or set of mapping set that was used to derive the mapping set.
         */
        MAPPING_SET_SOURCE(List.class),
        
        /**
         * STRING The display name of a mapping set.
         */
        MAPPING_SET_TITLE,
        
        /**
         * STRING A description of the mapping set.
         */
        MAPPING_SET_DESCRIPTION,
        
        /**
         * MAP STRING TO STRING: Curie map which maps the short form (prefix) to its long form.
         */
        CURIE_MAP(Map.class),
        
        /****************************************************************************
         * Keys to be used on a Correspondence Level
         ****************************************************************************/
        
        /**
         * STRING: The ID of the subject of the mapping.
         */
        SUBJECT_ID(true),
        
        /**
         * STRING: The label of subject of the mapping
         */
        SUBJECT_LABEL,        
        
        /**
         * STRING: 	The conceptual category to which the subject belongs to.
         * This can be a string denoting the category or a term from a controlled vocabulary.
         * This slot is deliberately underspecified. Conceptual categories can range from those
         * that are found in general upper ontologies such as BFO (e.g. process, temporal region, etc)
         * to those that serve as upper ontologies in specific domains, such as COB or BioLink (e.g. gene, disease, chemical entity).
         * The purpose of this optional field is documentation for human reviewers - when a category is known and documented clearly,
         * the cost of interpreting and evaluating the mapping decreases.
         */
        SUBJECT_CATEGORY,
        
        /**
         * STRING: The ID of the predicate or relation that relates the subject and object of this match.
         */
        PREDICATE_ID(true),        
        
        /**
         * STRING: The label of the predicate/relation of the mapping
         */
        PREDICATE_LABEL,
        
        /**
         * {@link SSSOMPredicateModifier} A modifier for negating the prediate. See https://github.com/mapping-commons/sssom/issues/40 for discussion
         */
        PREDICATE_MODIFIER(SSSOMPredicateModifier.class),
        
        /**
         * STRING: The ID of the object of the mapping.
         */
        OBJECT_ID(true),
        
        /**
         * STRING: The label of object of the mapping
         */
        OBJECT_LABEL,
        
        /**
         * STRING: The conceptual category to which the subject belongs to. This can be a string denoting the category or a term from
         * a controlled vocabulary. This slot is deliberately underspecified. Conceptual categories can range from those that are found
         * in general upper ontologies such as BFO (e.g. process, temporal region, etc) to those that serve as upper ontologies in specific domains,
         * such as COB or BioLink (e.g. gene, disease, chemical entity). The purpose of this optional field is documentation
         * for human reviewers - when a category is known and documented clearly, the cost of interpreting and evaluating the mapping decreases.
         */
        OBJECT_CATEGORY,
        
        /**
         * STRING: A mapping justification is an action (or the written representation of that action) of showing a mapping to be right or reasonable.
         */
        MAPPING_JUSTIFICATION(true),
        
        /**
         * LIST OF STRINGS: Identifies the persons or groups responsible for asserting the mappings.
         * Recommended to be a (pipe-separated) list of ORCIDs or otherwise identifying URLs,
         * but any identifying string (such as name and affiliation) is permissible.
         */
        AUTHOR_ID(true, List.class),
        
        /**
         * LIST OF STRINGS: A string identifying the author of this mapping. In the spirit of provenance, consider to use author_id instead.
         */
        AUTHOR_LABEL(List.class),
        
        /**
         * LIST OF STRINGS: Identifies the persons or groups that reviewed and confirmed the mapping.
         * Recommended to be a (pipe-separated) list of ORCIDs or otherwise identifying URLs,
         * but any identifying string (such as name and affiliation) is permissible.
         */
        REVIEWER_ID(true, List.class),
        
        /**
         * LIST OF STRINGS: A string identifying the reviewer of this mapping. In the spirit of provenance, consider to use reviewer_id instead.
         */
        REVIEWER_LABEL(List.class),
        
        /**
         * STRING: The mapping set this mapping was originally defined in.
         * mapping_source is used for example when merging multiple mapping sets or deriving one mapping set from another.
         */
        MAPPING_SOURCE(true),
        
        /**
         * {@link SSSOMMappingCardinality} A string indicating whether this mapping is from a 1:1 (the subject_id maps to a single object_id),
         * 1:n (the subject maps to more than one object_id), n:1, 1:0, 0:1 or n:n group.
         * Note that this is a convenience field that should be derivable from the mapping set.
         */
        MAPPING_CARDINALITY(SSSOMMappingCardinality.class),
        

        /**
         * Double: A score between 0 and 1 to denote the confidence or probability that the match is correct, where 1 denotes total confidence.
         */
        CONFIDENCE(Double.class),
        
        /**
         * LIST OF STRINGS: A curation rule is a (potentially) complex condition executed by an agent that led to the establishment of a mapping.
         * Curation rules often involve complex domain-specific considerations, which are hard to capture in an automated fashion.
         * The curation rule is captured as a resource rather than a string, which enables higher levels of transparency and sharing
         * across mapping sets. The URI representation of the curation rule is expected to be a resolvable identifier which provides details
         * about the nature of the curation rule.
         */
        CURATION_RULE(true, List.class),
        
        /**
         * LIST OF STRINGS: A curation rule is a (potentially) complex condition executed by an agent that led to the establishment of a mapping.
         * Curation rules often involve complex domain-specific considerations, which are hard to capture in an automated fashion.
         * The curation rule should be captured as a resource (entity reference) rather than a string (see curation_rule element),
         * which enables higher levels of transparency and sharing across mapping sets. The textual representation of curation rule
         * is intended to be used in cases where (1) the creation of a resource is not practical from the perspective
         * of the mapping_provider and (2) as an additional piece of metadata to augment the curation_rule element with a human readable text.
         */
        CURATION_RULE_TEXT(List.class),
        
        /**
         * LIST OF STRINGS: Strings that are shared by subj/obj.
         * It is recommended to indicate the fields for the match using the object and subject_match_field slots.
         */
        MATCH_STRING(List.class),
        
        /**
         * Double: A score between 0 and 1 to denote the semantic similarity, where 1 denotes equivalence.
         */
        SEMANTIC_SIMILARITY_SCORE(Double.class),
        
        /**
         * STRING: The measure used for computing the the semantic similarity score.
         * To make processing this field as unambiguous as possible, we recommend using wikidata identifiers,
         * but wikipedia pages could also be acceptable.
         */
        SEMANTIC_SIMILARITY_MEASURE;
        
        
        /**
         * The URI of the extension label.
         */
        private String uri;
        private boolean isEntityReference;
        private Class<?> clazz;
        public static final String BASE_URI = "https://w3id.org/sssom/schema/";
        
        private static final Map<String,SSSOM> URL_MAP;
        private static final Map<String,SSSOM> NAME_MAP;
        
        SSSOM(Class<?> clazz){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
            this.isEntityReference = false;
            this.clazz = clazz;
        }
        
        SSSOM(boolean isEntityReference, Class<?> clazz){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
            this.isEntityReference = isEntityReference;
            this.clazz = clazz;
        }
        
        SSSOM(boolean isEntityReference){
            this.uri = BASE_URI + this.name().toLowerCase(Locale.ENGLISH);
            this.isEntityReference = isEntityReference;
            this.clazz = String.class;
        }
        
        SSSOM(){
            this(false);
        }

        @Override
        public String toString(){
            return this.uri;
        }

        /**
         * Return true, if the value of this key can have an abbreviated value which needs to be expanded. 
         * @return true, if the value of this key can have an abbreviated value which needs to be expanded. 
         */
        public boolean isEntityReference() {
            return isEntityReference;
        }

        public Class<?> getDatatype() {
            return clazz;
        }
        
        /**
         * Return the name of the extension key as it should be used as a header in a TSV file.
         * @return just the name of the extension key.
         */
        public String getHeaderName(){
            return this.name().toLowerCase(Locale.ENGLISH);
        }
        
        static {
            Map<String,SSSOM> urlMap = new ConcurrentHashMap<>();
            Map<String,SSSOM> nameMap = new ConcurrentHashMap<>();
            for (SSSOM instance : SSSOM.values()) {
                urlMap.put(instance.toString(), instance);
                nameMap.put(instance.name().toLowerCase(Locale.ENGLISH), instance);
            }
            URL_MAP = Collections.unmodifiableMap(urlMap);
            NAME_MAP = Collections.unmodifiableMap(nameMap);
        }
        
        public static SSSOM fromURL(String url){
            return URL_MAP.get(url);
        }
        
        public static SSSOM fromName(String name){
            return NAME_MAP.get(name.toLowerCase(Locale.ENGLISH)); 
        }
        
        public static SSSOM fromURLOrName(String urlOrName){
            SSSOM tmp = fromURL(urlOrName);
            if(tmp!=null)
                return tmp;
            return fromName(urlOrName);
        }
    }


    /**
     * Additional vocabulary introduced with the MELT framework.
     */
    public enum MeltExtensions {
        /**
         * The confidence by the annotator of the gold standard for a particular correspondence.
         * This is required because the confidence in the alignment/correspondence is ALWAYS set by the matcher (hence,
         * 0 in the case of false positives). In order to also track the annotators confidence, this extension can
         * be used.
         */
        GOLD_STANDARD_CONFIDENCE("http://melt.dws.uni-mannheim.de/vocabulary#gold-standard-confidence"),
        
        /**
         * The typ of ml split. Usually the values are string which can be "reain", "val", "test".
         */
        ML_SPLIT("http://melt.dws.uni-mannheim.de/vocabulary#ml-split"),
        
        /**
         * The base URI that is to be used with extension predicates that have to be defined "on the spot" and
         * require a base URI. 
         */
        CONFIGURATION_BASE("http://melt.dws.uni-mannheim.de/configuration#"),
        
        
         /**
         * The key of the extension should end with this suffix, to be detected as an additional confidence.
         * The value should be castable to double.
         * This is required if you chain matchers.
         * e.g. structural_matcher_confidence -&gt; 0.9,
         *      string_matcher_confidence -&gt; 0.8
         */
        ADDITIONAL_CONFIDENCE_SUFFIX("_confidence"),
        
        
        /**
         * The key of the extension should end with this suffix, to be detected as an additional explanation.
         * The value should be castable to String.
         * e.g. structural_matcher_explanation -&gt; "match is between ... and ... is added because...",
         *      string_matcher_explanation -&gt; "match is between ... and ... is added because..."
         */
        ADDITIONAL_EXPLANATION_SUFFIX("_explanation");
        
        /**
         * The URI of the extension label.
         */
        private String uri;

        MeltExtensions(String uri){
            this.uri = uri;
        }

        @Override
        public String toString(){
            return this.uri;
        }
    }


}
