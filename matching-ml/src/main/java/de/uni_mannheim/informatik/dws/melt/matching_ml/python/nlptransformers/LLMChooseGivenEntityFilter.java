package de.uni_mannheim.informatik.dws.melt.matching_ml.python.nlptransformers;

import de.uni_mannheim.informatik.dws.melt.matching_base.FileUtil;
import de.uni_mannheim.informatik.dws.melt.matching_base.Filter;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Alignment;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Correspondence;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.rdf.model.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import de.uni_mannheim.informatik.dws.melt.matching_jena.TextExtractor;
import de.uni_mannheim.informatik.dws.melt.matching_jena.TextExtractorMap;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.CorrespondenceConfidenceComparator;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * This filter asks the LLM given a source entity which is the best target entity (out of the ones in the alignment).
 * Afterwards the same is done in the reversed direction.
 */
public class LLMChooseGivenEntityFilter extends LLMBase implements Filter {

    private static final String NEWLINE = System.getProperty("line.separator");
    
    private static final Logger LOGGER = LoggerFactory.getLogger(LLMChooseGivenEntityFilter.class);
    
    protected boolean useNumbers;
    
    public static final String BINARY_ADDITIONAL_CONFIDENCE_KEY = LLMChooseGivenEntityFilter.class.getSimpleName() + "Binary";
    
    /**
     * Constructor with all required parameters and default values for optional parameters (can be changed by setters).
     * It uses the systems default tmp dir to store the files with texts generated from the knowledge graphs.
     * Pytorch is used instead of tensorflow and all visible GPUs are used for prediction.
     * @param extractor the extractor to select which text for each resource should be used.
     * @param modelName the model name which can be a model id (a hosted model on huggingface.co) or a path to a directory containing a model and tokenizer
     * (<a href="https://huggingface.co/transformers/main_classes/model.html#transformers.PreTrainedModel.from_pretrained">
     * see first parameter pretrained_model_name_or_path of the from_pretrained
     * function in huggingface library</a>). In case of a path, it should be absolute. 
     * The path can be generated by e.g. {@link FileUtil#getCanonicalPathIfPossible(java.io.File) }
     * @param promt The promt to use for the LLM. Use text {candidates} to insert the text representation of all candidates with alphabetical enumerations.
     */
    public LLMChooseGivenEntityFilter(TextExtractorMap extractor, String modelName, String promt) {
        super(extractor, modelName, promt);
        this.useNumbers = false;
    }
    
    /**
     * Constructor with all required parameters and default values for optional parameters (can be changed by setters).
     * It uses the systems default tmp dir to store the files with texts generated from the knowledge graphs.
     * Pytorch is used instead of tensorflow and all visible GPUs are used for prediction.
     * @param extractor the extractor to select which text for each resource should be used.
     * @param modelName the model name which can be a model id (a hosted model on huggingface.co) or a path to a directory containing a model and tokenizer
     * (<a href="https://huggingface.co/transformers/main_classes/model.html#transformers.PreTrainedModel.from_pretrained">
     * see first parameter pretrained_model_name_or_path of the from_pretrained
     * function in huggingface library</a>). In case of a path, it should be absolute. 
     * The path can be generated by e.g. {@link FileUtil#getCanonicalPathIfPossible(java.io.File) }
     * @param promt The promt to use for the LLM. Use {left} and {right} to insert the text representation of the left and right concept.
     */
    public LLMChooseGivenEntityFilter(TextExtractor extractor, String modelName, String promt) {
        this(TextExtractorMap.wrapTextExtractor(extractor), modelName, promt);
    }
    
    @Override
    public Alignment match(OntModel source, OntModel target, Alignment inputAlignment, Properties properties) throws Exception {
        for(Correspondence c : inputAlignment){
            c.addAdditionalConfidence(this.getClass(), 0.0d); // initialize it
            c.addAdditionalConfidence(BINARY_ADDITIONAL_CONFIDENCE_KEY, 0);
        }
        List<List<Correspondence>> correspondenceList = new ArrayList<>();
        Map<Resource,String> cache = new HashMap<>();
        int examplesWrote = 0;
        int maxNumberOfCandidates = 0;
        File file = FileUtil.createFileWithRandomNumber("alignment_llm_predict", ".txt");
        try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))){
            
            for(String sourceEntity : inputAlignment.getDistinctSources()){
                
                String sourceRepresentation = getOneTextualRepresentation(source.getResource(sourceEntity), cache);
                if(sourceRepresentation.isEmpty())
                    continue;
                List<Correspondence> sameSource = getList(inputAlignment.getCorrespondencesSource(sourceEntity));
                
                List<Correspondence> finalList = new ArrayList<>(sameSource.size());
                int count = 0;
                StringBuilder candidatesText = new StringBuilder();
                for(Correspondence c : sameSource){
                    String oneTargetRepresentation = getOneTextualRepresentation(target.getResource(c.getEntityTwo()), cache);
                    if(oneTargetRepresentation.isEmpty())
                        continue;
                    
                    finalList.add(c);
                    candidatesText.append("\t ").append(getEnumerationLabel(count)).append(") ").append(oneTargetRepresentation).append("\n");
                    count++;
                }
                correspondenceList.add(finalList);
                if(finalList.size() > maxNumberOfCandidates){
                    maxNumberOfCandidates = finalList.size();
                }
                writer.write(StringEscapeUtils.escapeCsv(sourceRepresentation) + "," + StringEscapeUtils.escapeCsv(candidatesText.toString()) + NEWLINE);
                examplesWrote++;
            }
            
            for(String targetEntity : inputAlignment.getDistinctTargets()){
                
                String targetRepresentation = getOneTextualRepresentation(target.getResource(targetEntity), cache);
                if(targetRepresentation.isEmpty())
                    continue;
                List<Correspondence> sameTarget = getList(inputAlignment.getCorrespondencesTarget(targetEntity));
                
                List<Correspondence> finalList = new ArrayList<>(sameTarget.size());
                int count = 0;
                StringBuilder candidatesText = new StringBuilder();
                for(Correspondence c : sameTarget){
                    String oneSourceRepresentation = getOneTextualRepresentation(source.getResource(c.getEntityOne()), cache);
                    if(oneSourceRepresentation.isEmpty())
                        continue;
                    
                    finalList.add(c);
                    candidatesText.append("\t ").append(getEnumerationLabel(count)).append(") ").append(oneSourceRepresentation).append("\n");
                    count++;
                }
                correspondenceList.add(finalList);
                if(finalList.size() > maxNumberOfCandidates){
                    maxNumberOfCandidates = finalList.size();
                }
                writer.write(StringEscapeUtils.escapeCsv(targetRepresentation) + "," + StringEscapeUtils.escapeCsv(candidatesText.toString()) + NEWLINE);
                examplesWrote++;
            }
        }
        LOGGER.info("Wrote {} examples to prediction file {}", examplesWrote, file);
        if(examplesWrote == 0){
            LOGGER.warn("No correspondences have enough text to be processed (the input alignment has {} " +
                    "correspondences) - the input alignment is returned unchanged.", inputAlignment.size());
            return inputAlignment;
        }
        try{
            //we generate the words to detect for the maximum number of canidates - later on we restrict it per line
            List<Set<String>> wordToDetect = generateWordsToDetect(maxNumberOfCandidates);
            LOGGER.info("Run prediction");
            List<List<Double>> confidenceList = predictConfidences(file, wordToDetect);
            LOGGER.info("Finished prediction");
            
            for(int i = 0; i < confidenceList.size(); i++){
                List<Double> confidenceLine = confidenceList.get(i);
                List<Correspondence> correspondenceLine = correspondenceList.get(i);
                
                double sum = 0.0;
                for(int k = 0; k < correspondenceLine.size(); k++){ // use only confidences which are actually useful for this line
                    sum += confidenceLine.get(k);
                }
                double confNone = confidenceLine.get(confidenceLine.size() - 1); //for predicting "None" e.g. last element
                sum += confNone;
                
                int bestPos = -1;
                double bestConf = 0.0;
                for(int k=0; k < correspondenceLine.size(); k++){
                    Correspondence c = correspondenceLine.get(k);
                    double confidence = confidenceLine.get(k);
                    c.addAdditionalConfidenceIfHigher(this.getClass(), confidence/sum);
                    if(confidence > bestConf){
                        bestConf = confidence;
                        bestPos = k;
                    }
                }
                
                //for filtering
                if(bestConf >= confNone){
                    //one correspondence is better than None prediction -> use it and set the addittional confidence to 1 (for filtering)
                    correspondenceLine.get(bestPos).addAdditionalConfidence(BINARY_ADDITIONAL_CONFIDENCE_KEY, 1.0);
                }//else {
                    //none is the best -> filter all
                    //keep the this.getClass().getSimpleName() + "binary" to 0 which is already set at the top /beginning of this method
                //}
            }
        }finally{
            file.delete();
        }
        return inputAlignment;
    }
    
    private String getEnumerationLabel(int i){
        if(this.useNumbers){
            return Integer.toString(i);
        }else{
            //max 26 elements - alphabet
            if (i >= 0 && i <= 25) {
                return String.valueOf((char) ('a' + i));
            } else {
                return "?";
            }
        }
    }
    private List<Correspondence> getList(Iterable<Correspondence> a){
        if(this.useNumbers){
            return Alignment.createOrder(Alignment.makeList(a));
        }else{
            //max 26 elements - alphabet
            List<Correspondence> sortedAlignment = Alignment.makeList(a);
            sortedAlignment.sort(new CorrespondenceConfidenceComparator().reversed()
                .thenComparing(Correspondence::getEntityOne)
                .thenComparing(Correspondence::getEntityTwo));
            List<Correspondence> sublist = new ArrayList<>(sortedAlignment.subList(0, Math.min(26, sortedAlignment.size())));
            return Alignment.createOrder(sublist);
        }
    }
    
    private List<Set<String>> generateWordsToDetect(int maxNumberOfCandidates){
        List<Set<String>> wordsToDetect = new ArrayList<>();
        
        for(int i = 0 ; i < maxNumberOfCandidates; i++){
            if(this.useNumbers){
                wordsToDetect.add(includeMoreVariations(Integer.toString(i)));
            }else{
                wordsToDetect.add(includeMoreVariations(getEnumerationLabel(i)));
            }
        }
        wordsToDetect.add(includeMoreVariations("none"));
        return wordsToDetect;
    }    
    
    protected String getOneTextualRepresentation(Resource r, Map<Resource, String> cache){
        String cacheResult = cache.get(r);
        if(cacheResult != null)
            return cacheResult;
        Map<String, Set<String>> texts = this.extractor.extract(r);
        if(texts.isEmpty()){
            cache.put(r, "");
            return "";
        }else{
            Set<String> selectedTexts;
            if(texts.size() == 1){
                selectedTexts = texts.entrySet().iterator().next().getValue();
            }else{
                LOGGER.warn("There are multiple texts extracted by text extractor which is not allowed for LLMChooseFilter. Random text is selected");
                selectedTexts = new HashSet<>();
                for(Entry<String, Set<String>> entry : texts.entrySet()){
                    selectedTexts.addAll(entry.getValue());
                }
            }
            if(selectedTexts.isEmpty()){
                cache.put(r, "");
                return "";
            }
            if(selectedTexts.size() > 1){
                LOGGER.warn("There are multiple texts extracted by text extractor in one set which is not allowed for LLMChooseFilter. Random text is selected");
            }
            String finalSelected = selectedTexts.iterator().next(); 
            cache.put(r, finalSelected);
            return finalSelected;
        }
    }
}
